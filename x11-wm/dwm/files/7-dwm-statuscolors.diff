--- a/drw.h   2017-05-23 02:21:37.168667505 -0400
+++ b/drw.h   2017-05-20 23:44:40.833219790 -0400
@@ -50,6 +50,8 @@
 void drw_setscheme(Drw *drw, Scm scm);

 /* Drawing functions */
+int drw_get_width(Drw *, int, const char *);
+void drw_colored_text(Drw *, Scm *, int, int, int, unsigned int, unsigned int, char *);
 void drw_rect(Drw *drw, int x, int y, unsigned int w, unsigned int h, int filled, int invert);
 int drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, unsigned int lpad, const char *text, int invert);

--- a/drw.c 2017-05-23 02:21:37.168667505 -0400
+++ b/drw.c 2017-05-21 00:04:22.679247878 -0400
@@ -222,6 +222,68 @@
 		drw->scheme = scm;
 }

+int
+drw_get_width(Drw *drw, int numcolors, const char *text)
+{
+	int i;
+	Fnt *curfont = &(drw->fonts[0]);
+	int w = drw_text(drw, 0, 0, 0, 0, 0, text, 0) + curfont->h;
+
+	for (i = 0; i < strlen(text); i++) {
+		if (text[i] > 0 && text[i] <= numcolors) {
+			/* we found a color code
+			 * drw_text counted it as a normal character and added one character's width
+			 * we aren't going to render this character, so we remove one character's width */
+			w -= curfont->xfont->max_advance_width;
+
+			if (i == 0 || i + 1 == strlen(text)) {
+				/* we're on the first or the last character of the string
+				 * drw_text already added one character's height (divided by 2) as padding to the beginning and end
+				 * we don't want to double this padding, so we skip this character */
+				continue;
+			}
+
+			if (text[i - 1] > 0 && text[i - 1] <= numcolors) {
+				/* the previous character was also a color code
+				 * we already added padding in the previous iteration
+				 * we don't want to double this padding, so we skip this character */
+				continue;
+			}
+
+			/* we are somewhere in the middle of the string and the color has changed
+			 * we want to add one character's height (divided by 2) as padding to the end of the previous colored text
+			 * and to the beginning of the new colored text */
+			w += curfont->h;
+		}
+	}
+
+  return w;
+}
+
+void
+drw_colored_text(Drw *drw, Scm *scheme, int numcolors, int x, int y, unsigned int w, unsigned int h, char *text)
+{
+    //if (!drw || drw->scheme)
+	//	return;
+
+	char *buf = text, *ptr = buf, c = 1;
+	int i;
+
+	while (*ptr) {
+		for (i = 0; *ptr < 0 || *ptr > numcolors; i++, ptr++);
+		if (!*ptr)
+			break;
+		c = *ptr;
+		*ptr = 0;
+		if (i)
+			x = drw_text(drw, x, y, drw_fontset_getwidth(drw, buf), h, 0, buf, 0) + (drw->fonts[0].h / 2);
+		*ptr = c;
+		drw_setscheme(drw, scheme[c-1]);
+		buf = ++ptr;
+	}
+	drw_text(drw, x, y, w, h, 0, buf, 0);
+}
+
 void
 drw_rect(Drw *drw, int x, int y, unsigned int w, unsigned int h, int filled, int invert)
 {
--- a/dwm.c	2017-05-23 02:22:28.551668727 -0400
+++ b/dwm.c	2017-05-21 00:20:47.745271290 -0400
@@ -725,8 +725,9 @@
 	/* draw status first so it can be overdrawn by tags later */
 	if (m == selmon || 1) { /* status is only drawn on selected monitor */
 		drw_setscheme(drw, scheme[SchemeNorm]);
-		sw = TEXTW(stext) - lrpad + 2; /* 2px right padding */
-		drw_text(drw, m->ww - sw, 0, sw, bh, 0, stext, 0);
+		sw = TEXTW(stext) - lrpad + 4;
+        //sw = drw_get_width(drw, LENGTH(colors), stext) - lrpad + 2; /* 2px right padding */
+		drw_colored_text(drw, scheme, LENGTH(colors), m->ww - sw, 0, sw, bh, stext);
 	}

 	for (c = m->clients; c; c = c->next) {
